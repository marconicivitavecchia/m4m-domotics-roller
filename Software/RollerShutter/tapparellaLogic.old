#include "tapparellaLogic.h"

int count1 = 0;
unsigned long target[2];

byte tapparellaLogic(byte (&in)[NBTN*BTNDIM], byte (&inr)[NBTN*BTNDIM], byte (&outLogic)[NBTN*STATUSDIM], unsigned long thalt, int n){
	//ad ogni pressione del tasto 1 entro il tempo prefissato attiva il motore nella DIRSezione A
	//in=digitalReaoutd(tasto1);
	//switch attivo su entrambi i fronti
	int offset=n*STATUSDIM;
	int toffset=n*TIMERDIM;
	int poffset=n*BTNDIM;
	int soffset=n*OUTDIM;
    byte changed = 0;
	
	
	//pulsante UP
	if(switchdfn(in[BTN1IN+poffset],BTN1IN+poffset))
	{
		//siamo su uno dei fronti del pulsante UP
		if(in[BTN1IN+poffset]>0)  
		{			
			//fronte di salita
			startTimer(RESETTIMER);
			//DEBUG_PRINTLN(F("Partito il timer di reset"));
			
			updateCnt(n);
			if(testCntEvnt(1,n))
				{
					startTimer(CNTIMER1+n);
					//DEBUG_PRINT(F("Partito il timer di attivazione servizi a conteggio gruppo "));
					//DEBUG_PRINTLN(n+1);
				}
				
			outLogic[SW1ONS+offset]=true;
			if(!outLogic[SW2ONS+offset]){  //evita attivazioni con pressione contemporanea di due tasti
				//effettuata prima pressione
				if(getTimerState(TMRHALT+toffset)==0){ 	//se il motore è fermo	
					DEBUG_PRINT(F("\nPrima pressione UP: motore "));
					DEBUG_PRINT(n+1);
					DEBUG_PRINT(F(" in moto verso l'alto "));
					DEBUG_PRINTLN(in[BTN1IN+poffset]);
		
					resetTimer(TMRHALT+toffset);			
					if(in[BTN1IN+poffset] == 1 || in[BTN1IN+poffset] == 2){
						//LIST OF UP ACTIONS
						setupTimer(thalt - getCronoCount(n),TMRHALT+toffset);
						
						//imposta la DIRSezione
						outLogic[DIRS+offset]=LOW;	
						//abilita il motore
						outLogic[ENABLES+offset]=HIGH;
						//fai partire il timer di fine corsa
						startTimer(TMRHALT+toffset);
						
						//fai partire il cronometro di UP
						setCronoDir(UP,n);
						startCrono(n); 		//crono gruppo di pulsanti
					}else if(in[BTN1IN+poffset] > 2){ //aperture percentuali
						target[n] = (unsigned long) (thalt/100)*in[BTN1IN+poffset];
						DEBUG_PRINT(F("\nTARGET "));
						DEBUG_PRINTLN(target[n]);
						if(target[n] > getCronoCount(n)){
							//LIST OF UP ACTIONS (TARGET ABOVE CURRENT POS)
							setupTimer(target[n] - getCronoCount(n),TMRHALT+toffset);
							
							outLogic[DIRS+offset]=LOW;	
							//abilita il motore
							outLogic[ENABLES+offset]=HIGH;
							
							//fai partire il timer di fine corsa
							startTimer(TMRHALT+toffset);
							//fai partire il cronometro di UP
							//startCrono(BTNUP+poffset); 	  //crono pulsante
							setCronoDir(UP,n);
							startCrono(n); 		//crono gruppo di pulsanti
						}else{ //TARGET UNDER CURRENT POS
							DEBUG_PRINT(F("\nREVERSE "));
							DEBUG_PRINTLN(in[BTN1IN+poffset]);
						    //LIST OF UP ACTIONS
							setupTimer(0,TMRHALT+toffset);
							
							DEBUG_PRINT(F("\nStop UP"));
							//DEBUG_PRINTLN(F("1)fronte di discesa simulato (rilascio simulato dei pulsanti)"));
							for(int i=0;i<4;i++)
								inr[i]=LOW;
							//viene impostato il tempo massimo di durata della corsa del motore THALTMAX
							tapparellaLogic(inr,inr,outLogic,thalt,n);
							DEBUG_PRINT(F("\nStart DOWN"));
							for(int i=0;i<4;i++)
								inr[i]=LOW;
							inr[BTN2IN+poffset] = in[BTN1IN+poffset];
							tapparellaLogic(inr,inr,outLogic,thalt,n);
						}
					}
				}
				else
				{
					//effettuata seconda pressione
					DEBUG_PRINT(F("\nSeconda pressione UP: motore "));
					DEBUG_PRINT(n+1);
					DEBUG_PRINT(F(" fermo al tempo "));
					DEBUG_PRINTLN(getCronoCount(n));
					
					//LIST OF STOP ACTIONS
					resetTimer(TMRHALT+toffset);//blocca timer di fine corsa
					
					//blocca il motore
					outLogic[ENABLES+offset]=LOW;
					outLogic[DIRS+offset]=LOW;
					
					//blocca il cronometro di DOWN
					//stopCrono(BTNUP+poffset);  //crono pulsante
					addCronoCount(stopCrono(n),getCronoDir(n),n);
					onTapStop(n);
				}
				changed = 1;
				//onUpPressed(n);
			}
		}
		else
		{
			//fronte di discesa
			//DEBUG_PRINTLN(F("Rilascio pulsanti"));
			outLogic[SW1ONS+offset]=false;
			changed=255;
			//ferma il timer di reset
			//Tasto rilasciato: blocca il timer di reset
			resetTimer(RESETTIMER);
			//DEBUG_PRINTLN(F("Bloccato il timer di reset"));
		}
	
	}
	
	//pulsante DOWN
	if(switchdfn(in[BTN2IN+poffset],BTN2IN+poffset)){
		//siamo su uno dei fronti del pulsante Down
		if(in[BTN2IN+poffset]>0) 
		{
			//fronte di salita
			outLogic[SW2ONS+offset]=true;
			if(!outLogic[SW1ONS+offset]){  //evita attivazioni con pressione contemporanea di due tasti
				
				resetCnt(CNTSERV1);
				resetCnt(CNTSERV2);
				
				//effettuata prima pressione
			    if(getTimerState(TMRHALT+toffset)==0){ //se il motore è fermo
					DEBUG_PRINT(F("\nPrima pressione DOWN: motore "));
					DEBUG_PRINT(n+1);
					DEBUG_PRINT(F(" in moto verso il basso al tempo "));
					DEBUG_PRINTLN(getCronoCount(n));
					
					resetTimer(TMRHALT+toffset);
					if(in[BTN2IN+poffset] == 1 || in[BTN2IN+poffset] == 2){
						//LIST OF DOWN ACTIONS
						setupTimer(getCronoCount(n),TMRHALT+toffset);	
						
						//imposta la DIRSezione
						outLogic[DIRS+offset]=HIGH;	
						//abilita il motore
						outLogic[ENABLES+offset]=HIGH;
						
						//fai partire il timer di fine corsa
						startTimer(TMRHALT+toffset); 
						//fai partire il cronometro di DOWN
						setCronoDir(DOWN,n);
						startCrono(n); 		//crono gruppo di pulsanti
					}else if(in[BTN2IN+poffset] > 2){ //aperture percentuali
						target[n] = (unsigned long) (thalt/100)*in[BTN2IN+poffset];
						DEBUG_PRINT(F("\BTN2IN "));
						DEBUG_PRINTLN(in[BTN2IN+poffset]);
						DEBUG_PRINT(F("\nTARGET "));
						DEBUG_PRINTLN(target[n]);
						DEBUG_PRINT(F("\getCronoCount(n) "));
						DEBUG_PRINTLN(getCronoCount(n));
						if(getCronoCount(n)> target[n]){
							//LIST OF STOP ACTIONS  (TARGET ABOVE CURRENT POS)
							setupTimer(getCronoCount(n) - target[n],TMRHALT+toffset); 

							//imposta la DIRSezione
							outLogic[DIRS+offset]=HIGH;	
							//abilita il motore
							outLogic[ENABLES+offset]=HIGH;
							
							//fai partire il timer di fine corsa
							startTimer(TMRHALT+toffset); 
							//fai partire il cronometro di DOWN
							setCronoDir(DOWN,n);
							startCrono(n); 		//crono gruppo di pulsanti
						}else{ //TARGET UNDER CURRENT POS
							//LIST OF DOWN ACTIONS
							setupTimer(0,TMRHALT+toffset);  
							DEBUG_PRINT(F("\nREVERSE "));		
							DEBUG_PRINTLN(in[BTN1IN+poffset]);
							setupTimer(0,TMRHALT+toffset);
							DEBUG_PRINT(F("\nStop DOWN"));
							//DEBUG_PRINTLN(F("1)fronte di discesa simulato (rilascio simulato dei pulsanti)"));
							for(int i=0;i<4;i++)
								inr[i]=LOW;
							//viene impostato il tempo massimo di durata della corsa del motore THALTMAX
							tapparellaLogic(inr,inr,outLogic,thalt,n);
							for(int i=0;i<4;i++)
								inr[i]=LOW;
							DEBUG_PRINT(F("\ninr[BTN1IN+poffset] "));
							DEBUG_PRINTLN(thalt - target[n]);
							inr[BTN1IN+poffset] = in[BTN2IN+poffset];
							tapparellaLogic(inr,inr,outLogic,thalt,n);
						}
					}					
				}
				else
				{
					//effettuata seconda pressione
					DEBUG_PRINT(F("\nSeconda pressione DOWN: motore "));
					DEBUG_PRINT(n+1);
					DEBUG_PRINT(F(" fermo al tempo "));
					DEBUG_PRINTLN(getCronoCount(n));
					
					//LIST OF STOP ACTIONS
					resetTimer(TMRHALT+toffset);//blocca timer di fine corsa
										
					//blocca il motore
					outLogic[ENABLES+offset]=LOW;
					outLogic[DIRS+offset]=LOW;
					
					//blocca il cronometro di DOWN
					//stopCrono(BTNDOWN+poffset);  //crono pulsante
					addCronoCount(stopCrono(n),getCronoDir(n),n);
					onTapStop(n);
				}
				changed = 1;
				//onDownPressed(n);
			}
		}
		else
		{
			//fronte di discesa
			//DEBUG_PRINTLN(F("Rilascio pulsanti"));
			outLogic[SW2ONS+offset]=false;
			changed= 255;
		}
		
	}
	
	return changed;
}

long getTarget(byte n){
	return target[n];
}